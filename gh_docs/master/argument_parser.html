<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nimrod. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module argument_parser</title>
<style type="text/css">

span.DecNumber {color: blue}
span.BinNumber {color: blue}
span.HexNumber {color: blue}
span.OctNumber {color: blue}
span.FloatNumber {color: blue}
span.Identifier  {color: black}
span.Keyword {font-weight: bold}
span.StringLit {color: blue}
span.LongStringLit {color: blue}
span.CharLit {color: blue}
span.EscapeSequence {color: black}
span.Operator {color: black}
span.Punctuation {color: black}
span.Comment, span.LongComment {font-style:italic; color: green}
span.RegularExpression  {color: DarkViolet}
span.TagStart {color: DarkViolet}
span.TagEnd {color: DarkViolet}
span.Key  {color: blue}
span.Value  {color: black}
span.RawData {color: blue}
span.Assembler  {color: blue}
span.Preprocessor {color: DarkViolet}
span.Directive  {color: DarkViolet}
span.Command, span.Rule, span.Hyperlink, span.Label, span.Reference, 
span.Other  {color: black}

div.navigation {
  -moz-border-radius: 5px 5px 5px 5px;
  float: left; 
  width: 30%;
  margin: 0; padding: 0;
  border: 3px outset #7F7F7F;
  background-color: #7F7F7F;
}

div.navigation ul {
  list-style-type: none;
  padding-left: 1em;
}
div.navigation ul li a, div.navigation ul li a:visited {
  font-weight: bold;
  color: #FFFFFF;
  text-decoration: none;
}
div.navigation ul li a:hover {
  font-weight: bold;
  text-decoration: none;
  color: gold;
}

div.content {
  margin-left: 30%;
  padding: 0 1em;
  border-left: 4em;
}

dl.item dd, dl.item dd p {
  margin-top:3px;
}
dl.item dd pre {
  margin-left: 15pt;
  border: 0px;
}
dl.item dt, dl.item dt pre {
  margin:  20pt 0 0 5pt;
}

pre, span.tok {
  background-color: #F9F9F9;
  border-color: #C4C4C4;
  border-style: solid;
  border-width: 1px 1px 1px 2px;
  color: black;
  line-spacing: 110%;
  padding: 2px;
}

span.red {
  color: #A80000;
}

hr {background-color:#9D9D9D; border:0 none; color:#9D9D9D; height:1px; width:100%;}

/*
:Author: David Goodger
:Contact: goodger@python.org
:Date: Date: 2006-05-21 22:44:42 +0200 (Sun, 21 May 2006)
:Revision: Revision: 4564
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/
/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th { border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first { margin-top: 0 ! important }
.last, .with-subtitle { margin-bottom: 0 ! important }
.hidden { display: none }
a.toc-backref { text-decoration: none ; color: black }
blockquote.epigraph { margin: 2em 5em ; }
dl.docutils dd { margin-bottom: 0.5em }
div.abstract { margin: 2em 5em }
div.abstract p.topic-title { font-weight: bold ; text-align: center }
div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ; border: medium outset ; padding: 1em }
div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title { font-weight: bold ; font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title { color: red ; font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication { margin: 2em 5em ; text-align: center ; font-style: italic }
div.dedication p.topic-title { font-weight: bold ; font-style: normal }
div.figure { margin-left: 2em ; margin-right: 2em }
div.footer, div.header { clear: both; font-size: smaller }
div.line-block { display: block ; margin-top: 1em ; margin-bottom: 1em }
div.line-block div.line-block { margin-top: 0 ; margin-bottom: 0 ;
  margin-left: 1.5em }
div.sidebar { margin-left: 1em ; border: medium outset ;
  padding: 1em ; background-color: #ffffee ; /*width: 40% ;*/ float: right ;
  clear: right }

div.sidebar p.rubric { font-family: sans-serif ; font-size: medium }
div.system-messages { margin: 5em }
div.system-messages h1 { color: red }
div.system-message { border: medium outset ; padding: 1em }
div.system-message p.system-message-title { color: red ; font-weight: bold }
div.topic { margin: 2em;}
h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }
h1.title { text-align: center }
h2.subtitle { text-align: center }
/* hr.docutils { width: 75% } */
img.align-left { clear: left }
img.align-right { clear: right }
ol.simple, ul.simple { margin-bottom: 1em }
ol.arabic { list-style: decimal }
ol.loweralpha { list-style: lower-alpha }
ol.upperalpha { list-style: upper-alpha }
ol.lowerroman { list-style: lower-roman }
ol.upperroman { list-style: upper-roman }
p.attribution { text-align: right ; margin-left: 50% }
p.caption { font-style: italic }
p.credits { font-style: italic ; font-size: smaller }
p.label { white-space: nowrap }
p.rubric { font-weight:bold;font-size:larger;color:maroon;text-align:center}
p.sidebar-title {font-family: sans-serif ;font-weight: bold ;font-size: larger }
p.sidebar-subtitle {font-family: sans-serif ; font-weight: bold }
p.topic-title {
font-weight: bold;
background-color: #6D6D6D;
border-bottom: 1px solid #000000;
border-top: 1px solid black;
color: white;
text-align: center;
margin: 0;
}
pre.address { margin-bottom: 0;margin-top:0;font-family:serif;font-size:100% }
pre.literal-block, pre.doctest-block {margin-left: 2em ;margin-right: 2em }
span.classifier {font-family: sans-serif;font-style: oblique }
span.classifier-delimiter {font-family: sans-serif;font-weight: bold }
span.interpreted {font-family: sans-serif }
span.option {white-space: nowrap }
span.pre {white-space: pre }
span.problematic {color: red }
span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation { border-left: solid 1px gray; margin-left: 1px }
table.docinfo {margin: 2em 4em }
table.docutils {margin-top: 0.5em;margin-bottom: 0.5em; border: 0 solid #9d9d9d; border-collapse: collapse; }
table.footnote {border-left: solid 1px black;margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {padding-left: 0.5em;padding-right: 0.5em;
  vertical-align: top;}

table.docutils td, table.docutils th { border-bottom:1px solid #9D9D9D; }
/* color: #4d4d4d} */

/* table.docutils td:hover, table.docinfo td:hover {color: #000000} */
  

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold;text-align: left;white-space: nowrap;padding-left: 0 }
  
table.docutils th
{
color: black;
font-weight:normal;
background-color: #E3E3E3;
border-top: 1px solid #1d1d1d;
border-bottom: 1px solid #1d1d1d;
}
  
h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {font-size: 100% }
ul.auto-toc { list-style-type: none }
/*a.reference { color: #E00000; font-weight:bold;}
a.reference:hover {color: #E00000;background-color: #ffff00;display: margin;
  font-weight:bold;}*/

</style>

</head>
<body>
<div class="document" id="documentId">
<h1 class="title">Module argument_parser</h1>
<div class="navigation" id="navigation">
<ul class="simple">
<li>
  <a class="reference" href="#6" id="56">Imports</a>
  <ul class="simple">
    
  </ul>
</li>
<li>
  <a class="reference" href="#7" id="57">Types</a>
  <ul class="simple">
      <li><a class="reference" href="#Tparam_kind"
    title="Tparam_kind* = enum 
  PK_EMPTY, PK_INT, PK_FLOAT, PK_STRING, PK_BOOL, PK_BIGGEST_INT, 
  PK_BIGGEST_FLOAT, PK_HELP"><wbr />Tparam_<wbr />kind</a></li>
  <li><a class="reference" href="#Tparameter_callback"
    title="Tparameter_callback* = proc (parameter: string; value: var Tparsed_parameter): string"><wbr />Tparameter_<wbr />callback</a></li>
  <li><a class="reference" href="#Tparameter_specification"
    title="Tparameter_specification* = object 
  names*: seq[string]         ## List of possible parameters to catch for this.
  consumes*: Tparam_kind      ## Expected type of the parameter (empty for none)
  custom_validator*: Tparameter_callback ## Optional custom callback
                                         ## to run after type conversion.
  help_text*: string          ## Help for this group of parameters."><wbr />Tparameter_<wbr />specification</a></li>
  <li><a class="reference" href="#Tparsed_parameter"
    title="Tparsed_parameter* = object 
  case kind*: Tparam_kind
  of PK_EMPTY: nil
  of PK_INT: int_val*: int
  of PK_BIGGEST_INT: big_int_val*: BiggestInt
  of PK_FLOAT: float_val*: float
  of PK_BIGGEST_FLOAT: big_float_val*: BiggestFloat
  of PK_STRING: str_val*: string
  of PK_BOOL: bool_val*: bool
  of PK_HELP: nil"><wbr />Tparsed_<wbr />parameter</a></li>
  <li><a class="reference" href="#Tcommandline_results"
    title="Tcommandline_results* = object of TObject
  positional_parameters*: seq[Tparsed_parameter]
  options*: TOrderedTable[string, Tparsed_parameter]"><wbr />Tcommandline_<wbr />results</a></li>

  </ul>
</li>
<li>
  <a class="reference" href="#10" id="60">Consts</a>
  <ul class="simple">
      <li><a class="reference" href="#version_int"
    title="version_int* = (major: 0, minor: 4, maintenance: 1)"><wbr />version_<wbr />int</a></li>
  <li><a class="reference" href="#version_str"
    title="version_str* = ($ version_int.major &amp; &quot;.&quot; &amp; $ version_int.minor &amp; &quot;.&quot; &amp;
    $ version_int.maintenance)"><wbr />version_<wbr />str</a></li>

  </ul>
</li>
<li>
  <a class="reference" href="#12" id="62">Procs</a>
  <ul class="simple">
      <li><a class="reference" href="#$,Tparam_kind"
    title="`$`*(value: Tparam_kind): string">`<wbr />$`</a></li>
  <li><a class="reference" href="#init,Tparameter_specification,Tparameter_callback,varargs[string]"
    title="init*(param: var Tparameter_specification; consumes = PK_EMPTY; 
      custom_validator: Tparameter_callback = nil; help_text = &quot;&quot;; 
      names: varargs[string])"><wbr />init</a></li>
  <li><a class="reference" href="#new_parameter_specification,Tparameter_callback,varargs[string]"
    title="new_parameter_specification*(consumes = PK_EMPTY; 
                             custom_validator: Tparameter_callback = nil; 
                             help_text = &quot;&quot;; names: varargs[string]): Tparameter_specification"><wbr />new_<wbr />parameter_<wbr />specification</a></li>
  <li><a class="reference" href="#$,Tparsed_parameter"
    title="`$`*(data: Tparsed_parameter): string">`<wbr />$`</a></li>
  <li><a class="reference" href="#init,Tcommandline_results,seq[Tparsed_parameter],TOrderedTable[string,Tparsed_parameter]"
    title="init*(param: var Tcommandline_results; 
      positional_parameters: seq[Tparsed_parameter] = @ []; options: TOrderedTable[
    string, Tparsed_parameter] = initOrderedTable[string, Tparsed_parameter](4))"><wbr />init</a></li>
  <li><a class="reference" href="#$,Tcommandline_results"
    title="`$`*(data: Tcommandline_results): string">`<wbr />$`</a></li>
  <li><a class="reference" href="#echo_help,seq[Tparameter_specification]"
    title="echo_help*(expected: seq[Tparameter_specification] = @ []; 
           type_of_positional_parameters = PK_STRING; 
           bad_prefixes = @ [&quot;-&quot;, &quot;--&quot;]; end_of_options = &quot;--&quot;)"><wbr />echo_<wbr />help</a></li>
  <li><a class="reference" href="#parse,seq[Tparameter_specification],seq[TaintedString]"
    title="parse*(expected: seq[Tparameter_specification] = @ []; 
       type_of_positional_parameters = PK_STRING; 
       args: seq[TaintedString] = nil; bad_prefixes = @ [&quot;-&quot;, &quot;--&quot;]; 
       end_of_options = &quot;--&quot;; quit_on_failure = true): Tcommandline_results"><wbr />parse</a></li>
  <li><a class="reference" href="#build_help,seq[Tparameter_specification]"
    title="build_help*(expected: seq[Tparameter_specification] = @ []; 
            type_of_positional_parameters = PK_STRING; 
            bad_prefixes = @ [&quot;-&quot;, &quot;--&quot;]; end_of_options = &quot;--&quot;): seq[string]"><wbr />build_<wbr />help</a></li>
  <li><a class="reference" href="#echo_help,seq[Tparameter_specification]_2"
    title="echo_help*(expected: seq[Tparameter_specification] = @ []; 
           type_of_positional_parameters = PK_STRING; 
           bad_prefixes = @ [&quot;-&quot;, &quot;--&quot;]; end_of_options = &quot;--&quot;)"><wbr />echo_<wbr />help</a></li>

  </ul>
</li>
<li>
  <a class="reference" href="#18" id="68">Templates</a>
  <ul class="simple">
      <li><a class="reference" href="#new_parsed_parameter.t,Tparam_kind,"
    title="new_parsed_parameter*(tkind: Tparam_kind; expr): Tparsed_parameter"><wbr />new_<wbr />parsed_<wbr />parameter</a></li>

  </ul>
</li>

</ul>
</div>
<div class="content" id="content">
<p>Command line parsing module for Nim.</p>
<p>The <a class="reference external" href="http://nim-lang.org">Nim programming language</a> provides the <a class="reference external" href="http://nim-lang.org/parseopt.html">parseopt module</a> to parse options from the commandline. This module tries to provide functionality to prevent you from writing commandline parsing and let you concentrate on providing the best possible experience for your users.</p>
<p>Source code for this module can be found at <a class="reference external" href="https://github.com/gradha/argument_parser">https://github.com/gradha/argument_parser</a>.</p>

<div class="section" id="6">
<h1><a class="toc-backref" href="#56">Imports</a></h1>
<dl class="item">
<a class="reference external" href="os.html">os</a>, <a class="reference external" href="strutils.html">strutils</a>, <a class="reference external" href="tables.html">tables</a>, <a class="reference external" href="math.html">math</a>, <a class="reference external" href="parseutils.html">parseutils</a>, <a class="reference external" href="sequtils.html">sequtils</a>, <a class="reference external" href="sets.html">sets</a>, <a class="reference external" href="algorithm.html">algorithm</a>, <a class="reference external" href="unicode.html">unicode</a>
</dl></div>
<div class="section" id="7">
<h1><a class="toc-backref" href="#57">Types</a></h1>
<dl class="item">
<dt id="Tparam_kind"><a name="Tparam_kind"></a><pre><span class="Identifier">Tparam_kind</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">enum</span> 
  <span class="Identifier">PK_EMPTY</span><span class="Other">,</span> <span class="Identifier">PK_INT</span><span class="Other">,</span> <span class="Identifier">PK_FLOAT</span><span class="Other">,</span> <span class="Identifier">PK_STRING</span><span class="Other">,</span> <span class="Identifier">PK_BOOL</span><span class="Other">,</span> <span class="Identifier">PK_BIGGEST_INT</span><span class="Other">,</span> 
  <span class="Identifier">PK_BIGGEST_FLOAT</span><span class="Other">,</span> <span class="Identifier">PK_HELP</span></pre></dt>
<dd>
Different types of results for parameter parsing.

</dd>
<dt id="Tparameter_callback"><a name="Tparameter_callback"></a><pre><span class="Identifier">Tparameter_callback</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">parameter</span><span class="Other">:</span> <span class="Identifier">string</span><span class="Other">;</span> <span class="Identifier">value</span><span class="Other">:</span> <span class="Keyword">var</span> <span class="Identifier">Tparsed_parameter</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">string</span></pre></dt>
<dd>
<p>
Prototype of parameter callbacks</p>
<p>A parameter callback is just a custom proc you provide which is invoked after a parameter is parsed passing the basic type validation. The <cite>parameter</cite> parameter is the string which triggered the option. The <cite>value</cite> parameter contains the string passed by the user already parsed into the basic type you specified for it.</p>
<p>The callback proc has modification access to the Tparsed_parameter <cite>value</cite> parameter that will be put into Tcommandline_results: you can read it and also modify it, maybe changing its type. In fact, if you need special parsing, most likely you will end up specifying PK_STRING in the parameter input specification so that the parse() proc doesn't <em>mangle</em> the string before you can process it yourself.</p>
<p>If the callback decides to abort the validation of the parameter, it has to put into result a non zero length string with a message for the user explaining why the validation failed, and maybe offer a hint as to what can be done to pass validation.</p>


</dd>
<dt id="Tparameter_specification"><a name="Tparameter_specification"></a><pre><span class="Identifier">Tparameter_specification</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Identifier">names</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">string</span><span class="Other">]</span>         <span class="Comment">## List of possible parameters to catch for this.</span>
  <span class="Identifier">consumes</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Tparam_kind</span>      <span class="Comment">## Expected type of the parameter (empty for none)</span>
  <span class="Identifier">custom_validator</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Tparameter_callback</span> <span class="Comment">## Optional custom callback</span>
                                         <span class="Comment">## to run after type conversion.</span>
  <span class="Identifier">help_text</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">string</span>          <span class="Comment">## Help for this group of parameters.</span>
  </pre></dt>
<dd>
<p>
Holds the expectations of a parameter.</p>
<p>You create these objects and feed them to the parse() proc, which then uses them to detect parameters and turn them into something uself.</p>


</dd>
<dt id="Tparsed_parameter"><a name="Tparsed_parameter"></a><pre><span class="Identifier">Tparsed_parameter</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">object</span> 
  <span class="Keyword">case</span> <span class="Identifier">kind</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">Tparam_kind</span>
  <span class="Keyword">of</span> <span class="Identifier">PK_EMPTY</span><span class="Other">:</span> <span class="Keyword">nil</span>
  <span class="Keyword">of</span> <span class="Identifier">PK_INT</span><span class="Other">:</span> <span class="Identifier">int_val</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">int</span>
  <span class="Keyword">of</span> <span class="Identifier">PK_BIGGEST_INT</span><span class="Other">:</span> <span class="Identifier">big_int_val</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">BiggestInt</span>
  <span class="Keyword">of</span> <span class="Identifier">PK_FLOAT</span><span class="Other">:</span> <span class="Identifier">float_val</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">float</span>
  <span class="Keyword">of</span> <span class="Identifier">PK_BIGGEST_FLOAT</span><span class="Other">:</span> <span class="Identifier">big_float_val</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">BiggestFloat</span>
  <span class="Keyword">of</span> <span class="Identifier">PK_STRING</span><span class="Other">:</span> <span class="Identifier">str_val</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">string</span>
  <span class="Keyword">of</span> <span class="Identifier">PK_BOOL</span><span class="Other">:</span> <span class="Identifier">bool_val</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">bool</span>
  <span class="Keyword">of</span> <span class="Identifier">PK_HELP</span><span class="Other">:</span> <span class="Keyword">nil</span>
  </pre></dt>
<dd>
<p>
Contains the parsed value from the user.</p>
<p>This implements an object variant through the kind field. You can 'case' this field to write a generic proc to deal with parsed parameters, but nothing prevents you from accessing directly the type of field you want if you expect only one kind.</p>
<p>To create objects of this type you can use the <a class="reference external" href="#new_parsed_parameter">new_parsed_parameter()</a> template.</p>


</dd>
<dt id="Tcommandline_results"><a name="Tcommandline_results"></a><pre><span class="Identifier">Tcommandline_results</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">TObject</span>
  <span class="Identifier">positional_parameters</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">Tparsed_parameter</span><span class="Other">]</span>
  <span class="Identifier">options</span><span class="Operator">*</span><span class="Other">:</span> <span class="Identifier">TOrderedTable</span><span class="Other">[</span><span class="Identifier">string</span><span class="Other">,</span> <span class="Identifier">Tparsed_parameter</span><span class="Other">]</span>
</pre></dt>
<dd>
<p>
Contains the results of the parsing.</p>
<p>Usually this is the result of the parse() call, but you can inherit from it to add your own fields for convenience.</p>
<p>Note that you always have to access the <tt class="docutils literal"><span class="pre">options</span></tt> ordered table with the first variant of a parameter name. For instance, if you have an option specified like <tt class="docutils literal"><span class="pre">@[&quot;-s&quot;, &quot;--silent&quot;]</span></tt> and the user types <tt class="docutils literal"><span class="pre">--silent</span></tt> at the commandline, you have to use <tt class="docutils literal"><span class="pre">options.hasKey(&quot;-s&quot;)</span></tt> to test for it. This standarizes access through the first name variant for all options to avoid you repeating the test with different keys.</p>


</dd>

</dl></div>
<div class="section" id="10">
<h1><a class="toc-backref" href="#60">Consts</a></h1>
<dl class="item">
<dt id="version_int"><a name="version_int"></a><pre><span class="Identifier">version_int</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Other">(</span><span class="Identifier">major</span><span class="Other">:</span> <span class="DecNumber">0</span><span class="Other">,</span> <span class="Identifier">minor</span><span class="Other">:</span> <span class="DecNumber">4</span><span class="Other">,</span> <span class="Identifier">maintenance</span><span class="Other">:</span> <span class="DecNumber">1</span><span class="Other">)</span></pre></dt>
<dd>
<p>
Module version as an integer tuple.</p>
<p>Major versions changes mean a break in API backwards compatibility, either through removal of symbols or modification of their purpose.</p>
<p>Minor version changes can add procs (and maybe default parameters).</p>
<p>Maintenance version changes mean bugfixes or non API changes.</p>
<p>Odd versions are development/git/unstable versions. Even versions are public stable releases.</p>


</dd>
<dt id="version_str"><a name="version_str"></a><pre><span class="Identifier">version_str</span><span class="Operator">*</span> <span class="Other">=</span> <span class="Other">(</span><span class="Operator">$</span> <span class="Identifier">version_int</span><span class="Other">.</span><span class="Identifier">major</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot;.&quot;</span> <span class="Operator">&amp;</span> <span class="Operator">$</span> <span class="Identifier">version_int</span><span class="Other">.</span><span class="Identifier">minor</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot;.&quot;</span> <span class="Operator">&amp;</span>
    <span class="Operator">$</span> <span class="Identifier">version_int</span><span class="Other">.</span><span class="Identifier">maintenance</span><span class="Other">)</span></pre></dt>
<dd>
<p>
Module version as a string.</p>
<p>The string has the format <tt class="docutils literal"><span class="pre">digits.digits.digits</span></tt>.</p>


</dd>

</dl></div>
<div class="section" id="12">
<h1><a class="toc-backref" href="#62">Procs</a></h1>
<dl class="item">
<dt id="$"><a name="$,Tparam_kind"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Operator">$</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">value</span><span class="Other">:</span> <span class="Identifier">Tparam_kind</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">string</span> <span class="Other">{.</span><span class="Identifier">procvar</span><span class="Other">.}</span></pre></dt>
<dd>
Stringifies the type, used to generate help texts.

</dd>
<dt id="init"><a name="init,Tparameter_specification,Tparameter_callback,varargs[string]"></a><pre><span class="Keyword">proc</span> <span class="Identifier">init</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">param</span><span class="Other">:</span> <span class="Keyword">var</span> <span class="Identifier">Tparameter_specification</span><span class="Other">;</span> <span class="Identifier">consumes</span> <span class="Other">=</span> <span class="Identifier">PK_EMPTY</span><span class="Other">;</span> 
           <span class="Identifier">custom_validator</span><span class="Other">:</span> <span class="Identifier">Tparameter_callback</span> <span class="Other">=</span> <span class="Keyword">nil</span><span class="Other">;</span> <span class="Identifier">help_text</span> <span class="Other">=</span> <span class="StringLit">&quot;&quot;</span><span class="Other">;</span> 
           <span class="Identifier">names</span><span class="Other">:</span> <span class="Identifier">varargs</span><span class="Other">[</span><span class="Identifier">string</span><span class="Other">]</span><span class="Other">)</span></pre></dt>
<dd>
<p>Initialization helper with default parameters.</p>
<p>You can decide to miss some if you like the defaults, reducing code. You can also use new_parameter_specification() for single assignment variables.</p>


</dd>
<dt id="new_parameter_specification"><a name="new_parameter_specification,Tparameter_callback,varargs[string]"></a><pre><span class="Keyword">proc</span> <span class="Identifier">new_parameter_specification</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">consumes</span> <span class="Other">=</span> <span class="Identifier">PK_EMPTY</span><span class="Other">;</span> 
                                  <span class="Identifier">custom_validator</span><span class="Other">:</span> <span class="Identifier">Tparameter_callback</span> <span class="Other">=</span> <span class="Keyword">nil</span><span class="Other">;</span> 
                                  <span class="Identifier">help_text</span> <span class="Other">=</span> <span class="StringLit">&quot;&quot;</span><span class="Other">;</span> <span class="Identifier">names</span><span class="Other">:</span> <span class="Identifier">varargs</span><span class="Other">[</span><span class="Identifier">string</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Tparameter_specification</span></pre></dt>
<dd>
Initialization helper for single assignment variables.

</dd>
<dt id="$"><a name="$,Tparsed_parameter"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Operator">$</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">Tparsed_parameter</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">string</span> <span class="Other">{.</span><span class="Identifier">procvar</span><span class="Other">.}</span></pre></dt>
<dd>
<p>Stringifies the value, mostly for debug purposes.</p>
<p>The proc will display the value followed by non string type in brackets. The non string types would be PK_INT (i), PK_BIGGEST_INT (I), PK_FLOAT (f), PK_BIGGEST_FLOAT (F), PK_BOOL (b). The string type would be enclosed inside quotes. PK_EMPTY produces the word <cite>nil</cite>, and PK_HELP produces the world <cite>help</cite>.</p>


</dd>
<dt id="init"><a name="init,Tcommandline_results,seq[Tparsed_parameter],TOrderedTable[string,Tparsed_parameter]"></a><pre><span class="Keyword">proc</span> <span class="Identifier">init</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">param</span><span class="Other">:</span> <span class="Keyword">var</span> <span class="Identifier">Tcommandline_results</span><span class="Other">;</span> 
           <span class="Identifier">positional_parameters</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">Tparsed_parameter</span><span class="Other">]</span> <span class="Other">=</span> <span class="Operator">@</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">options</span><span class="Other">:</span> <span class="Identifier">TOrderedTable</span><span class="Other">[</span>
    <span class="Identifier">string</span><span class="Other">,</span> <span class="Identifier">Tparsed_parameter</span><span class="Other">]</span> <span class="Other">=</span> <span class="Identifier">initOrderedTable</span><span class="Other">[</span><span class="Identifier">string</span><span class="Other">,</span> <span class="Identifier">Tparsed_parameter</span><span class="Other">]</span><span class="Other">(</span><span class="DecNumber">4</span><span class="Other">)</span><span class="Other">)</span></pre></dt>
<dd>
Initialization helper with default parameters.

</dd>
<dt id="$"><a name="$,Tcommandline_results"></a><pre><span class="Keyword">proc</span> <span class="Other">`</span><span class="Operator">$</span><span class="Other">`</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">data</span><span class="Other">:</span> <span class="Identifier">Tcommandline_results</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">string</span></pre></dt>
<dd>
Stringifies a Tcommandline_results structure for debug output

</dd>
<dt id="echo_help"><a name="echo_help,seq[Tparameter_specification]"></a><pre><span class="Keyword">proc</span> <span class="Identifier">echo_help</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">expected</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">Tparameter_specification</span><span class="Other">]</span> <span class="Other">=</span> <span class="Operator">@</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">;</span> 
                <span class="Identifier">type_of_positional_parameters</span> <span class="Other">=</span> <span class="Identifier">PK_STRING</span><span class="Other">;</span> 
                <span class="Identifier">bad_prefixes</span> <span class="Other">=</span> <span class="Operator">@</span> <span class="Other">[</span><span class="StringLit">&quot;-&quot;</span><span class="Other">,</span> <span class="StringLit">&quot;--&quot;</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">end_of_options</span> <span class="Other">=</span> <span class="StringLit">&quot;--&quot;</span><span class="Other">)</span></pre></dt>
<dd>


</dd>
<dt id="parse"><a name="parse,seq[Tparameter_specification],seq[TaintedString]"></a><pre><span class="Keyword">proc</span> <span class="Identifier">parse</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">expected</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">Tparameter_specification</span><span class="Other">]</span> <span class="Other">=</span> <span class="Operator">@</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">;</span> 
            <span class="Identifier">type_of_positional_parameters</span> <span class="Other">=</span> <span class="Identifier">PK_STRING</span><span class="Other">;</span> 
            <span class="Identifier">args</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">TaintedString</span><span class="Other">]</span> <span class="Other">=</span> <span class="Keyword">nil</span><span class="Other">;</span> <span class="Identifier">bad_prefixes</span> <span class="Other">=</span> <span class="Operator">@</span> <span class="Other">[</span><span class="StringLit">&quot;-&quot;</span><span class="Other">,</span> <span class="StringLit">&quot;--&quot;</span><span class="Other">]</span><span class="Other">;</span> 
            <span class="Identifier">end_of_options</span> <span class="Other">=</span> <span class="StringLit">&quot;--&quot;</span><span class="Other">;</span> <span class="Identifier">quit_on_failure</span> <span class="Other">=</span> <span class="Identifier">true</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Tcommandline_results</span></pre></dt>
<dd>
<p>Parses parameters and returns results.</p>
<p>The expected array should contain a list of the parameters you want to detect, which can capture additional values. Uncaptured parameters are considered positional parameters for which you can specify a type with type_of_positional_parameters.</p>
<p>Before accepting a positional parameter, the list of bad_prefixes is compared against it. If the positional parameter starts with any of them, an error is displayed to the user due to ambiguity. The user can overcome the ambiguity by typing the special string specified by end_of_options. Note that values captured by parameters are not checked against bad prefixes, otherwise it would be a problem to specify the dash as synonim for standard input for many programs.</p>
<p>The args sequence should be the list of parameters passed to your program without the program binary (usually OSes provide the path to the binary as the zeroth parameter). If args is nil, the list will be retrieved from the OS.</p>
<p>If there is any kind of error and quit_on_failure is true, the quit proc will be called with a user error message. If quit_on_failure is false errors will raise exceptions (usually EInvalidValue or EOverflow) instead for you to catch and handle.</p>


</dd>
<dt id="build_help"><a name="build_help,seq[Tparameter_specification]"></a><pre><span class="Keyword">proc</span> <span class="Identifier">build_help</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">expected</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">Tparameter_specification</span><span class="Other">]</span> <span class="Other">=</span> <span class="Operator">@</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">;</span> 
                 <span class="Identifier">type_of_positional_parameters</span> <span class="Other">=</span> <span class="Identifier">PK_STRING</span><span class="Other">;</span> 
                 <span class="Identifier">bad_prefixes</span> <span class="Other">=</span> <span class="Operator">@</span> <span class="Other">[</span><span class="StringLit">&quot;-&quot;</span><span class="Other">,</span> <span class="StringLit">&quot;--&quot;</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">end_of_options</span> <span class="Other">=</span> <span class="StringLit">&quot;--&quot;</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span>
    <span class="Identifier">string</span><span class="Other">]</span></pre></dt>
<dd>
<p>Builds basic help text and returns it as a sequence of strings.</p>
<p>Note that this proc doesn't do as much sanity checks as the normal parse() proc, though it's unlikely you will be using one without the other, so if you had a parameter specification problem you would find out soon.</p>


</dd>
<dt id="echo_help"><a name="echo_help,seq[Tparameter_specification]_2"></a><pre><span class="Keyword">proc</span> <span class="Identifier">echo_help</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">expected</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">Tparameter_specification</span><span class="Other">]</span> <span class="Other">=</span> <span class="Operator">@</span> <span class="Other">[</span><span class="Other">]</span><span class="Other">;</span> 
                <span class="Identifier">type_of_positional_parameters</span> <span class="Other">=</span> <span class="Identifier">PK_STRING</span><span class="Other">;</span> 
                <span class="Identifier">bad_prefixes</span> <span class="Other">=</span> <span class="Operator">@</span> <span class="Other">[</span><span class="StringLit">&quot;-&quot;</span><span class="Other">,</span> <span class="StringLit">&quot;--&quot;</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">end_of_options</span> <span class="Other">=</span> <span class="StringLit">&quot;--&quot;</span><span class="Other">)</span></pre></dt>
<dd>
<p>Prints out help on the terminal.</p>
<p>This is just a wrapper around build_help. Note that calling this proc won't exit your program, you should call quit() yourself.</p>


</dd>

</dl></div>
<div class="section" id="18">
<h1><a class="toc-backref" href="#68">Templates</a></h1>
<dl class="item">
<dt id="new_parsed_parameter"><a name="new_parsed_parameter.t,Tparam_kind,"></a><pre><span class="Keyword">template</span> <span class="Identifier">new_parsed_parameter</span><span class="Operator">*</span><span class="Other">(</span><span class="Identifier">tkind</span><span class="Other">:</span> <span class="Identifier">Tparam_kind</span><span class="Other">;</span> <span class="Identifier">expr</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Tparsed_parameter</span></pre></dt>
<dd>
<p>Handy compile time template to build <a class="reference external" href="#Tparsed_parameter">Tparsed_parameter</a> object variants.</p>
<p>Through this template you specify as the first parameter the kind of the <a class="reference external" href="#Tparsed_parameter">Tparsed_parameter</a> you want to build, and directly the value it will be initialised with. The template figures out at compile time what field to assign the variable to, and thus you reduce code clutter and may use this to initialise single assignments variables in <cite>let</cite> blocks. Example:</p>
<pre><span class="Keyword">let</span>
  <span class="Identifier">parsed_param1</span> <span class="Operator">=</span> <span class="Identifier">new_parsed_parameter</span><span class="Punctuation">(</span><span class="Identifier">PK_FLOAT</span><span class="Punctuation">,</span> <span class="FloatNumber">3.41</span><span class="Punctuation">)</span>
  <span class="Identifier">parsed_param2</span> <span class="Operator">=</span> <span class="Identifier">new_parsed_parameter</span><span class="Punctuation">(</span><span class="Identifier">PK_BIGGEST_INT</span><span class="Punctuation">,</span> <span class="DecNumber">2358123</span> <span class="Operator">*</span> <span class="DecNumber">23123</span><span class="Punctuation">)</span>
  <span class="Comment"># The following line doesn't compile due to</span>
  <span class="Comment"># type mismatch: got (string) but expected 'int'</span>
  <span class="Comment">#parsed_param3 = new_parsed_parameter(PK_INT, &quot;231&quot;)</span></pre><p>At some point the Nim programming language introduced initialization of object variants through a new constructor syntax where you specify the names of the fields you want to initialise. The new constructor syntax is slightly more verbose and you need to know which field of the <a class="reference external" href="#Tparsed_parameter">Tparsed_parameter</a> you want to set, but it has the advantage of working with runtime variables, something this template doesn't support.  The constructor syntax looks like this:</p>
<pre><span class="Keyword">let</span>
  <span class="Identifier">parsed_param1</span> <span class="Operator">=</span> <span class="Identifier">Tparsed_parameter</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">PK_FLOAT</span><span class="Punctuation">,</span>
    <span class="Identifier">float_val</span><span class="Punctuation">:</span> <span class="FloatNumber">3.41</span><span class="Punctuation">)</span>
  <span class="Identifier">parsed_param2</span> <span class="Operator">=</span> <span class="Identifier">Tparsed_parameter</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">PK_BIGGEST_INT</span><span class="Punctuation">,</span>
    <span class="Identifier">big_int_val</span><span class="Punctuation">:</span> <span class="DecNumber">2358123</span> <span class="Operator">*</span> <span class="DecNumber">23123</span><span class="Punctuation">)</span>
  <span class="Identifier">parsed_param3</span> <span class="Operator">=</span> <span class="Identifier">Tparsed_parameter</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">PK_INT</span><span class="Punctuation">,</span> <span class="Identifier">str_val</span><span class="Punctuation">:</span> <span class="StringLit">&quot;231&quot;</span><span class="Punctuation">)</span></pre><p>Note however that this new constructor syntax won't catch the error where <tt class="docutils literal"><span class="pre">parsed_param3</span></tt> is being assigned an incorrect field at compile time: you will get an <tt class="docutils literal"><span class="pre">EInvalidField</span></tt> exception raised at runtime in debug builds, and also in release builds if you compile with <tt class="docutils literal"><span class="pre">--fieldChecks:on</span></tt>.</p>


</dd>

</dl></div>

</div>

<small>Generated: 2015-01-17 19:57:51 UTC</small>
</div>
</body>
</html>
